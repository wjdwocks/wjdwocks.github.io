# C++ 기말고사 정리
---

## 목차
1. [8주차 - String](#8주차-standard-library2-&rarr;-string)
    - [String Constructor](#1-string-copyconstructer)
    - [Substr function](#2-substr-operation)
    - [String's Modify function](#3-change-strings-문자열-변경)
    - [String.find()](#4-문자열-내의-문자열을-찾는-find함수)
    - [String의 형변환](#5-정수나-실수형을-문자열로-바꾸는-함수)
2. [8주차 - Container](#8주차-standard-library-2-→-container-adaptors)
    - [Standard Container](#1-stack-queue-priority_queue)
    - [컨테이너 정의](#2-각-컨테이너들을-정의하는-방법)
    - [컨테이너의 주요 함수](#3-각-컨테이너들의-주요-멤버함수)
    - [우선순위 큐](#4-prioirty_queue에-대하여)
3. [9주차 - standard library's Function](#9주차-standard-libaray3-→-algorithm-라이브러리)
    - [find (read only)](#1-find-함수-read-only)
    - [accumulate (read only)](#2-numeric헤더-파일에-있는-accumulate함수-read-only)
    - [equal (read only)](#3-algorithm헤더파일에-들어있는-stdequal함수-read-only)
    - [fill (read and write)](#4-algorithm-헤더파일에-있는-fill-함수-read-and-write)
    - [for_each (read and write)](#5-algorithm헤더에-있는-for_each-함수)
    - [copy (read and write)](#6-algorithm헤더에-있는-copy-함수-read-and-write)
    - [reaplce (read and write)](#7-algorithm-헤더에-있는-copy와-비슷한-replace-알고리즘-read-and-write)
    - [sort & unique](#8-sort함수-와-unique함수)
4. [9주차 - 함수를 parameter로 받는 함수에서 함수를 커스텀하기.](#9주차-standard-libaray3-→-customizing-operations)
    - [sort customizing](#1-sort함수의-마지막-인자로-직접-정렬순서를-커스텀할-수도-있다)
    - [stable_sort](#2-stable_sort-함수를-통해-같은-우선순위를-가진-원소들-사이에는-원래의-순서를-유지하게-할-수-있다)
    - [find_if](#3-find_if-함수를-통해-container의-itr1--itr2사이에서-조건을-만족하는-첫번째-원소의-iterator를-반환함)
    - [lambda expression](#4-lambda-expression)
    - [for_each](#5-algorithm헤더에-있는-for_each-함수)
    - [lambda 표현식을 사용한 예제](#6-정렬---중복-제거---길이순-정렬---길이가-4-이하인-단어-제거---출력-예제)
    - [lambda -> value capture & reference capture](#7-람다-표현식의-값-capture와-참조-cpature)
    - [mutable expression in lambda expression](#8-람다-표현식에서의-mutable)
    - [return type in lambda expression](#9-람다-표현식에서-반환-타입의-정의)

5. [9주차 - 삽입 iterator](#2-삽입-iterator)
    - [inserter](#1-back_inserter와-front_inserter)
    - [inserter iterator](#2-삽입-iterator)

6. [10주차 - map과 set](#10주차-standard-library-3)
    - [10주차 - map과 set](#10주차-standard-library-3)
    - [10주차 - map과 set의 변수, 함수](#2-map과-set에서의-여러-내부-변수와-삽입-삭제-함수들)

7. [11주차 - 동적 메모리](#11주차-dynamic-memory)

8. [12주차 -1 copycontrol](#12주차--1--copy-control)
    - [12주차 -2 copy control에서의 자원관리](#12주차--2--copy-control에서의-자원-관리)
    - [12주차 -3 copy-control예시 - 이메일 클래스](#12주차--3--copy-control의-예시--이메일-클래스)
    - [12주차 -4 copy-control예시 - StrVector 구현](#12주차---4-strvector-구현)
## 8주차 standard library2 &rarr; string

### 1. String copyconstructer

- string에서 copyconstructor의 argument에 따라서 여러가지의 값이 새로운 객체에 전달된다.

1. 다른 객체가 전달되는 경우

``` cpp
std::string a = "hello world";
std::string b(a);  
printf(b); // b는 a와 같은 값을 가지고 있다. (b == hello world)
```

2. 다른 객체와 정수 하나가 전달되는 경우.

``` cpp
std::string a = "hello world";
std::string b(a, 6);
std::cout << b; // b에는 a의 6번째 문자부터 마지막까지의 부분문자열을 갖게 됨. (b == world)
```

3. 다른 객체와 정수 두개가 전달되는 경우.

``` cpp
std::string a = "hello world";
std::string b(a, 1, 4);
std::cout << b; // b에는 a의 1번째 문자를 포함한 뒤로 4개의 문자를 갖게 됨. (b == ello)
```
위의 경우들은 string클래스의 멤버함수인 substr과 매우 비슷하다.

### 2. Substr Operation

- string의 멤버 함수인 substr은 바뀐 문자열의 복사본을 반환하고, parameter에 따라 여러 기능을 한다.

1. 정수 하나만 전달되는 경우.

``` cpp
std::string str("Hello world");
std::string str2 = s.substr(6);
std::cout << str2; // str2에는 str의 6번째 문자 ~ 마지막까지의 문자열이 들어가게 된다.
// str2 == "world"
```

2. 정수 두개가 전달되는 경우.

``` cpp
std::string str = "Hello world";
std::string str2 = s.substr(6, 2);
std::cout << str2; // str2에는 str의 6번째 문자 ~ 2개의 문자열이 들어가게 된다. 
// str2 == "wo"
```

3. 예외.

만약 두번째 parameter가 원래 객체의 총 길이보다 길어도 상관은 없지만 첫번째 parameter가 객체의 총 길이보다 크다면 error가 발생하게 된다.

### 3. Change Strings. (문자열 변경)

- 크게 insert, erase, assign, append, replace의 함수들이 있다. 모두 객체의 상태를 변화시킬 수 있는 &반환형 함수임.

1. insert는 문자열 뒤에 문자들을 이어붙일 때 사용

``` cpp
string s = "hello world";
s.insert(s.size(), 5, '!');
cout << s; // insert함수를 통해 s.size()의 위치부터 5개의 '!'를 이어붙임.
// s == "hello world!!!!!"
```

2. erase는 문자열의 일정 부분을 없앨 때 사용.

``` cpp
string s = "hello world";
s.erase(s.size() - 5, 5);
cout << s; // erase를 통해 s.size() - 5 부터 뒤로 5개의 문자들을 삭제함.
// s == "hello "
```

3. assign 함수를 이용해서 C-style의 const char* 문자열을 string에 할당할 수 있다.

``` cpp
const char* cp = "Stately, plump Buck";
string s; // s는 공백 문자열.
s.assign(cp, 7); // s에 cp의 앞에서 7개의 문자들을 넣고.
s.insert(s.size(), cp+7); // s의 마지막에 cp+7번째 문자열부터 넣음.
cout << s; // s == cp.
```

4. append 함수는 insert함수의 축소형이다.

``` cpp
string s("C++ Primer"), s2 = s;
s.insert(s.size(), " 4th Ed.");
s.append(" 4th Ed.");
// 위의 두 행동은 같다.
```

5. replace 함수는 지정한 위치 + n개의 문자열을 내가 원하는 문자열로 대체할 수 있다. 없애는 문자열의 길이보다 추가할 문자열이 더 길거나 짧아도 상관없다.

``` cpp
s.erase(11, 3);
s.inser(11, "5th");

s2. replace(11, 3, "5th");
// 위의 두 행동은 같다.
```

### 4. 문자열 내의 문자열을 찾는 find함수.
- find함수는 문자열 내의 작은 문자열을 찾고, 만약 있다면 그 substr의 시작 index를 반환한다. find함수는 대소문자를 구분하기 때문에 정확히 입력해야함.

```cpp
string name("AnnaBelle");
auto pos1 = name.find("Anna");
// pos1 == 0
string lowercase("annabelle");
pos1 = lowercase.find("Anna");
// pos1 == npos -> 문자열을 찾지 못했을 때 반환하는 값.
```

### 5. 정수나 실수형을 문자열로 바꾸는 함수.

- cpp의 라이브러리 string에서는 to_string(int or float), stod(string) 등과 같이 숫자 &rarr; 문자열, 문자열 &rarr; 숫자로 바꾸는 함수가 존재한다.

``` cpp
#include <string>

int i = 42;
double d = 3.14;
std::string si = std::to_string(i);
std::string sd = std::to_string(d);

std::string str1 = "314";
std::string str2 = "3.14";
int i1 = stoi(str1); // i1 == 314
double d1 = stod(str2); // d1 == 3.14
```

---
<br/>

## 8주차 standard library 2 &rarr; Container Adaptors

### 1. stack, queue, priority_queue
- standard library에 정의된 세개지 타입의 sequential container이다. 

### 2. 각 컨테이너들을 정의하는 방법

```cpp
std::deque<int> deq = {1,2,3,4,5,6,7,8}; // deque자료구조를 선언하고, int형 변수들을 넣을거라고 generic에 넣음. 
//그 container의 이름은 deq으로 정의하고, {1,2,3,4,5,6,7,8}이 들어가도록 초기화함.
std::stack<int> stk(deq); // stack자료구조를 가진 container를 선언하고, int형 변수들을 저장할거라고 generic에 넣음.
// 그 container의 이름은 stk로 하고, deq의 원소들을 copy constructor를 이용해서 받아옴.
```

### 3. 각 컨테이너들의 주요 멤버함수.

```cpp
stk.push_back(3); // == stk.emplace_back(3)
// 스텍의 맨 뒤에 3을 추가함.
stk.pop_back();
// 스텍의 맨 뒤의 숫자를 제거함.
stk.top();
// 스텍의 맨 뒤의 숫자를 반환함. (얻어옴.)
```

### 4. prioirty_queue에 대하여
- prioirty_queue는 큐 자로구조를 기반으로 하지만 각 원소들의 우선순위를 정하여 pop()을 할 때마다 가장 우선순위가 큰 것먼저 내보내는 방식이다.

---

## 9주차 standard libaray3 &rarr; algorithm 라이브러리.

### 1. find 함수. (read only)
- algorithm 밑의 find 함수는 특정 컨테이너 안에 특정 value가 있는지 확인하기 위해서 사용된다. 찾는 데에 성공한다면 그 요소의 위치를 반환하게 되고, 실패한다면 itr2를 반환하게 된다. 즉, itr1 ~ itr2-1 까지의 요소를 확인하는 것이다.

``` cpp
std::find(itr1, itr2, val); // 의 형태로 사용됨.
// ex) 벡터
std::vector<int> v = {1,2,3,4,5,6,7,8};
auto ret = std::find(v.cbegin(), v.cend(), 0); // ret == v.cend()일 것이다.
auto ret2 = std::find(v.cbegin(), v.cend(), 8); // ret == v.cbegin()+7 == v.cend()-1일 것이다.
// ex2) 배열
int ia[] = {27, 210, 12, 47, 109, 83};
int val = 83;
int* result = std::find(std::begin(ia), std::end(ia), val);
// result에는 ia + 5의 값이 들어있을 것이다. 즉, ia + 5 == result;
```

- find 함수는 iterator만 있다면 container의 종류에 무관하게 사용 가능하다.

### 2. numeric헤더 파일에 있는 accumulate함수. (read only)
- std::accumulate(v.cbegin(), v.cend(), val);의 형식으로 정의되어있다. itr1 ~ itr2-1의 원소들을 모두 더한다. 근데 초기값을 val로 함.


- (+) string 도 operator+ 가 정의되어있어서 accumulate를 사용할 수 있다. 하지만 초기값을 ""와 같은 문자열을 넣을 수 없고, string클래스의 생성자를 이용하여 사용해야 한다.

ex)

```cpp
#include <numeric>
std::vector<int> v1 = {1,2,3,4,5,6,7,8,9,10};
int ret = std::accumulate(v1.cbegin(), v1.cend(), 0);
// ret에는 1~10까지의 모든 원소가 더해진 값이 저장됨.
std::vector<std::string> v2 = {"재찬", " 해성", " 존경"};
std::string sret = std::accumulate(v2.cbegin(), v2.cbegin()+3, string("name : "));
// sret에는 "name : 재찬 해성 존경"이 저장됨.
```

### 3. algorithm헤더파일에 들어있는 std::equal함수. (Read only)
- equal함수는 두 시퀀스가 동일한 값을 가지고 있는지 여부를 알려주는 역할을 한다.<br/>(boolean 변수를 반환함.)

- 함수의 형태 : bool ret = std::equal(v.cbegin(), v.cend(), v2.cbegin());<br/> 이것이 성립해야하기 때문에 적어도 두번 째 시퀀스가 적어도 첫번째 시퀀스만큼의 크기를 가진다고 가정함. &rarr; v1.size <= v2.size <br/>(그렇지 않으면 에러 발생.)

``` cpp
#include <algorithm>
std::vector<int> v = {1,2,3,4,5,6,7};
std::list<int> l = {1,2,3,4,5,6};
bool ret = std::equal(l.cbegin(), l.cend(), v.cbegin());
// ret에는 True가 들어가게 됨.
bool ret2 = std::equal(v.cbegin(), v.cend(), l.cbegin()); // Error!
std::list<int> l2 = { 1,2,3,4,5,7 };
bool ret3 = std::equal(v.cbegin(), v.cend(), l2.cbegin());
// ret3 == False
```

### 4. Algorithm 헤더파일에 있는 fill 함수. (Read and Write)

- fill함수는 컨테이너의 일정 영역(범위)를 내가 원하는 값으로 채우는 역할을 한다.

- 함수 형태 : std::fill(itr1, itr2, val); // return은 모르겠따.
<br/> itr ~ itr2-1 범위의 값들을 val로 바꿈/채움.

```cpp
#include <algorithm>
std::vector<int> v(10, 0);
std::fill(v.begin(), v.begin() + v.size()/2, 5);
// v에는 {5 5 5 5 5 0 0 0 0 0}이 남아있게 된다.
```

- 유사한 fill_n함수.

```cpp
std::vector<int> v(10, 0);
std::fill_n(v.begin(), v.size()/5, 5);
// 위와 같이 v에는 {5 5 5 5 5 0 0 0 0 0}이 남아있게 됨.
for (auto i : v)
	std::cout << i << ' ';
output : 5 5 5 5 5 0 0 0 0 0
```

### 5. iterator헤더파일에 들어있는 back_inserter함수. (Read and Write)
- 함수의 형태 : iterator itr = back_inserter(container); <br/>

- back_inserter함수는 이 컨테이너에 다음 원소가 들어갈 iterator를 반환해줌.

ex) 

```cpp
#include <iterator>
std::vector<int> v; // 공백 vector생성.
auto itr = std::back_inserter(v);
*itr = 6; // v.push_back(6)과 동등.
std::cout << v[0]; 

output : 6
```
back_inserter을 활용하는 예시.
```cpp
#include <iterator>
#include <algorithm>
vector<int> vec;
fill_n(back_inserter(vec), 10, 0);
print(vec) // 귀찮..

output : 10 10 10 10 10 10 10 10 10 10
```
- back_inserter()는 v.end()와 확연히 다르다. <br/>
end()는 그냥 마지막을 나타내는 문자열의 null과 비슷하지만, back_inserter()는 그 자리에 직접 원소를 추가할 수가 있다. (암튼 의미상 다름.)

### 6. algorithm헤더에 있는 copy 함수. (Read and Write)

- 함수 형태 : iterator ret = std::copy(itr1.begin, itr1.end, itr2);

- copy함수는 container1의 범위를 정하고, 이 범위 내의 원소들을 세번째 parameter에 전달된 iterator 뒤에 복사해서 붙여넣는 역할을 한다.

ex)

```cpp
int a1[] = {0,1,2,3,4,5,6,7,8,9};
int a2[sizeof(a1)/sizeof(*a1)];
auto ret = copy(begin(a1), end(a1), a2);
print(a2)
print(ret)

output : {0,1,2,3,4,5,6,7,8,9}
ret == a2 + 10
```

### 7. algorithm 헤더에 있는 copy와 비슷한 replace 알고리즘. (Read and Write)

- 함수 형태 : std::replace(li.begin(), li.end(), 0, 42); <br/>
itr1 ~ itr2 사이의 원소들 중 0인 원소를 42로 바꿈.

ex) replace 함수.

``` cpp
#include <algorithm>
std::list<int> li = {1,2,3,4,5};
std::replace(li.begin(), li.end(), 1, 42);
print(list)

output : [42, 2, 3, 4, 5]
```
- replace_copy함수도 있다. replace로 바꾼 복사본을 copy를 통해 다른 컨테이너의 뒤에 붙여넣음.<br/> 세번째 parameter로 container의 back_inserter를 받아온다.
ex) replace_copy

```cpp
#include <algorithm>
std::list<int> li = {1,2,3,4,5};
std::vector<int> v;
std::replace_copy(li.begin(), li.end(), std::back_inserter(v), 1, 42);
print(list)
print(v)

output : 
list = [1, 2, 3, 4, 5]
vector = {42, 2, 3, 4, 5}
```

### 8. Sort함수 와 unique함수
- sort를 통해 container를 정렬하고, unique함수를 통해서 중복된 개체를 없애줄 수 있다.
- unique함수를 사용하면 중복된 원소들을 뒤로 밀어버리고, 그 시작 위치를 반환하게 된다.<br/> 그러므로 erase(end_unique, end())를 통해 뒤를 다 지워주면 끝.

- 함수 형태 sort : std::sort(itr1, itr2);
- 함수 형태 unique : auto end_unique = std::unique(itr1, itr2);
ex)

```cpp
std::vector<int> arr = {3, 3, 2, 2, 1, 5, 4};
std::sort(arr.begin(), arr.end()); // arr = {1, 2, 2, 3, 3, 4, 5}
end_unique = std::unique(arr.begin(), arr.end()); // arr = {1, 2, 3, 4, 5, 2, 3}
arr.erase(end_unique, arr.end()); // 로 중복된 단어들 삭제. 
print(arr)

output : 
arr = {1,2,3,4,5}
```

---

## 9주차 standard libaray3 &rarr; Customizing Operations.

### 1. sort함수의 마지막 인자로 직접 정렬순서를 커스텀할 수도 있다.

ex)

```cpp
bool isShorter(const std::string& s1, const std::string& s2)
{
    return s1.size() < s2.size();
}

std::vector<std::string> v; // 안에 뭔가 있다고 가정하자.
std::sort(v.begin(), v.end(), isShorter); // 이렇게 내가 원하는 기준을 정해줄 수 있다.
// 이 때의 정렬 기준은 문자열의 길이 순서.
```

### 2. stable_sort 함수를 통해 같은 우선순위를 가진 원소들 사이에는 원래의 순서를 유지하게 할 수 있다.
ex)

```cpp
std::vector<std::string> v;
std::sort(v.begin(), v.end()); // 사전순으로 정렬하고,
std::stable_sort(v.begin(), v.end(), isShorter); // 길이순으로 한번 더 정렬.
// 위의 경우에서는 사전순으로 정렬을 먼저 하고, 그 순서를 유지하면서 크기순으로 한번 더 정렬한다. 
// 이렇게 하면 크기순 -> 사전순으로 정렬되게 된다.
```

### 3. find_if 함수를 통해 container의 itr1 ~ itr2사이에서 조건을 만족하는 첫번째 원소의 iterator를 반환함.

- find_if함수의 형태 : std::find_if(itr1, itr2, lambda expression);
- 여기서 여러 조건을 세번째 인자로 전달할 수 있도록 lambda expression을 사용하게 된다.


### 4. Lambda Expression.
- 람다 표현식은 간단히 말해서 이름이 없는 인라인 함수이다. 
- 기본 형태 : [capture list](parameter list) -> return type {function body}

ex) isShorter함수를 람다 표현식으로 만들어서 위의 두번의 sort를 수행하는 예제.

```cpp
std::vector<std::string> words;
sort(words.begin(), words.end())
stable_sort(words.begin(), words.end(), [](const std::string& a, const std::string& b) {return a.size() < b.size()>});

즉, isShorter과 위의 람다 표현식은 동등하다.
```

- 위의 isShorter함수를 람다 표현식으로 만드는 예제에서는 <br/>
[capture list](parameter list) -> return type {function body}의 형태에서 [capture list]를 사용하지 않았다.<br/>
[capture list]는 람다 표현식에서 사용할 외부 변수를 미리 지정해 놓는 것임.

ex) 위의 find_if의 예제를 보면 길이가 5 이상인 단어를 찾는 코드 작성 예제.

```cpp
std::vector<std::string> words;
int sz = 5;
auto itr = find_if(words.begin(), words.end(), [sz](const std::string& str) {return str.size() >= sz;});
// 만약 find_if에서 찾아지는 원소가 없다면 words.end()가 반환된다.
```

### 5. Algorithm헤더에 있는 for_each 함수.
- 함수 형태 : std::for_each(itr1, itr2, lambda expression) <br/>
itr1 ~ itr2 사이에 있는 모든 원소에 lambda expression을 수행함.

ex) for_each를 사용해서 모든 원소를 출력하는 예제 
```cpp
#include <algorithm>

std::vector<int> v = {1,2,3,4,5};
std::for_each(v.begin(), v.end(), [](const std::string& str) {std::cout << str << ' '})
```

### 6. 정렬 -> 중복 제거 -> 길이순 정렬 -> 길이가 4 이하인 단어 제거 -> 출력 예제

```cpp
vector<string> words;
sort(words.begin(), words.end()); 
// 사전순 정렬

end_unique = unique(words.begin(), words.end()); 
erase(end_unique, words.end()); 
// 중복 제거

stable_sort(words.begin(), words.end(), [](const string str1, const string str2) {return str1.size() < str2.size();>}); 
// 순서를 유지하며 길이순 정렬.

int sz = 5;
auto wc = find_if(words.begin(), words.end(), [sz](const string str){return str.size() >= sz;});
// 5이상인 단어가 나오는 첫번 째 위치(iterator)를 wc에 저장.

for_each(wc, words.end(), [](const string str){std::cout << str << ' ';});
// 5이상인 단어들만 사전순, 길이순으로 출력.
```

### 7. 람다 표현식의 값 capture와 참조 cpature.
- 람다 표현식에서 capture_list는 그 변수를 복사해서 람다 표현식 내에서 사용하는데 &로 받아오면 참조로 사용한다. 이는 stream들과 같이 복사가 안되는 것들을 사용할 때 쓰인다. <br/>
- 함수에서 지역 변수를 만들고 return할 수 없는 것처럼 & capture도 return할 수 없다.<br/>

- capture_list의 값을 [&] 나 [=]을 사용할 수도 있는데 이는 전역변수를 포함하여 람다 표현식이 포함되어있는 scope내의 모든 변수를 &참조캡쳐 or 값캡쳐로 이용한다는 뜻이다.

ex) 모든 변수를 값 캡쳐로 사용하는데 os객체만 & 캡쳐로 사용하고 싶을 때
```cpp
int a = 20;
std::ostream os;
auto lambda = [=, &os](){os << a << '\n';};
labmda();

output : 
20
```

### 8. 람다 표현식에서의 mutable
- 기본적으로 값으로 캡쳐한 외부 변수는 값을 변경할 수 없는데 바꾸고 싶다면 mutable을 선언해줘야 한다.

ex) 함수가 만들어지는 시점의 v1을 lambda에 넣음.
```cpp
size_t v1 = 42;
auto f = [v1] () mutable {return ++v1};
v1 = 0;
auto j = f(); // j == 43;
```

- reference로 캡쳐한 외부 변수에 대해서는 기본적으로 const만 아니라면 값을 변경할 수 있다.

ex) 함수가 호출되는 시점의 v1을 가져옴
```cpp
size_t v1 = 42;
auto f = [&v1](){return ++v1};
v1 = 0;
auto j = f(); // j == 1;
```

### 9. 람다 표현식에서 반환 타입의 정의
- 람다 표현식에서 return이 없으면 void를 반환함.

- 그런데 반환 타입을 명시하고 싶다면 trailing return type을 사용

ex) 절댓값으로 만들어서 int를 반환하는 람다함수.
```cpp
auto lambda = [](int i) -> int {if(i > 0) ? return i; : return -i;};
```

## 2. 삽입 iterator.
### 1. back_inserter와 front_inserter.
- back_inserter함수는 push_back을 하는 위치를 반환함.<br/>
front_inserter 함수는 push_front를 하는 위치를 반환함.<br/>
inserter함수는 insert()를 하는 위치를 반환함. <br/>
그런데 insert함수는 insert(val, itr)과 같이 위치를 정해주기 때문에 원래 itr이 가리키는 위치에 있는 원소 앞에 삽입을 하게 하여 결국 val이 itr에 위치하게 함.

### 2. reverse iterator.
- vector로 치면 v.rbegin()은 v.end()-1의 위치를 가리키고, v.rend()는 v.begin()-1의 위치를 가리키게 됨.<br/>
이를 통해 sort에 reverse iterator를 넣으면 역순으로 정렬된다.

---

## 10주차 Standard Library 3

### 1. Associative containers(map & set)
- map : python의 dictionary와 비슷. <br/>
각 원소가 key : value 의 형태로 되어있다. key의 중복을 허용하지 않는다.
- set : key값만이 존재한다. 중복을 허용하지 않음.

- map과 set은 insert와 emplace함수를 통해서 컨테이너에 원소를 추가하는데 이 때 기본적으로 정의된 < 연산자를 통해서 삽입과 동시에 정렬이 일어나게 된다.<br/>
하지만 컨테이너의 template 인자가 class와 같이 < 연산자를 사용할 수 없는 경우에는 사용자가 비교 함수를 생성하여 명시해 줄 수 있다.

ex) < 연산자를 명시해주면서 multiset을 만드는 예시
```cpp
bool compareIsbn(const Sales_data& lhs, const Sales_data& rhs)
{
    return lhs.isbn < rhs.isbn;
}

vector<Sales_data> v = {?? ?? ?? ?? ??};
multiset<Sales_data, decltype(compareIsbn)*> bookstore(compareIsbn); // 일반 생성자.
multiset<Sales_data, decltype(compareIsbn)*> bookstore2(v.begin(), v.end(), compareIsbn);
```

<br/> 


ex1) map을 사용하여 문장에서 특정 단어의 빈도수 체크.
```cpp
#include <map>

std::map<std::string, size_t> word_count;
std::string word;
while(std::cin >> word)
    ++word_count[word];
for (const auto& w : word_count)
    std::cout << w.first << " occurs" << w.second 
    << ((w.second > 1) ? " times" : " time") << std::endl;

1.  map에서 key값은 문자열, value값을 size_t형태로 정의함.
2.  ++word_count[word]; 를 하면, map안에서 word인 key 값이 있다면, 
    그 값을 +1 한다. 해당 key값이 없다면, 그 key를 만들고(0으로 초기화)
    그 값을 +1 한다.
```
ex2) set을 사용하여 문장에 특정 단어가 있는지 확인하는 예제
```cpp
#include <map>

std::map<std::string, size_t> word_count;
set<std::string> exclude = {"The", "But", "And", "Or", "An", "A", "the", "but", "and", "or", "an", "a"};
std::string word;
while(std::cin >> word)
    if(exclude.find(word) == exclude.end())
        ++world_count[word];

1.  cin을 통해 받아온 단어가 set에 해당하는 단어가 아니라면 
    그 단어를 map을 통해 빈도수를 늘린다.
2.  set의 find() 내장함수를 통해서 확인할 수 있다.
```

### 2. map과 set에서의 여러 내부 변수와 삽입, 삭제 함수들.
- map과 set에서는 key_type, value_type, mapped_type의 여러 타입이 있다.

| type    | key_type            | value_type          | mapped_type |
| ------- | ------------------- | ------------------- | ----------- |
| set     | key_type             | key_type              | none     |
| map     | key_type             | pair<key, value>    | value_type  |

- map과 set은 iterator의 dereference를 통해서 각 원소에 접근할 수 있다.

ex) iterator를 통해 각 원소에 접근하는 예제
```cpp
std::set<int> myset = {1,2,3,4,5,6};
std::map<int, int> mymap = {(1,2), (2,3), (3,4)};

auto itr = myset.begin();
auto itr2 = mymap.begin();

(*itr) = 42; // Error! key값은 const변수이기 때문에 에러.
print(*itr); // 1
print(itr2->first, itr2->second) // 1, 2
itr2->first = 42; // Error!
itr2->second = 42; // OK
```
- map, set, mutimap, multiset에서의 insert, emplace함수
    - map의 insert함수는 인자로 pair를 받는다.
    - set의 insert함수는 다른 컨테이너의 itr범위, list_initializer를 받을 수 있다.
    <br/>
    ref ) list_initializer는 {1,4,5,2,3} 과 같은 형태를 말함.
    - map의 insert와 emplace함수는 pair<방금 넣은 얘의 위치(iterator), 성공했는지   (boolean)>을 반환한다.
<br/> 실패했다면 삽입은 일어나지 않음.

- map, set, mutimap, multiset에서의 erase함수.
    1. erase의 parameter로 iterator 1개가 전달 된 경우.
        - 그 iterator가 가리키는 값을 삭제
    2. erase의 parameter로 iterator 2개가 전달 된 경우.
        - 그 iterator들의 범위 안의 원소들 삭제.
    3. erase의 parameter로 key_type의 값이 전달 된 경우.
        - 그 key값이 가리키는 값 or 값들을 모두 삭제.

- map에서의 at()함수와 []연산자.
    - map에서 map.at(key) 혹은 map[key] 라는 명령어는 해당 key값이 갖고있는 value값을 반환한다.
    - 만약 map.at(key)에서 key가 없다면 out of range가 발생.
    - 만약 map.find(key)에서 key가 없다면 map.end()를 반환함.
    - 만약 map[key] = 1에서 key가 없다면 새로운 key를 만들고, 그 value에 1을 대입.

## 11주차 Dynamic Memory
1. 스태틱 메모리, 스택 메모리, 힙 메모리.
    - static memory : Local static 객체, class static member, 전역 변수 등이 포함됨.
    - stack memory : static변수가 아닌 모든 지역 변수. 자동으로 생성되고, 삭제됨. 
    - Heap memory : 동적으로 할당한 변수나 객체들이 저장됨. 프로그램이 끝날때까지 내가 직접 삭제하지않는 한 사라지지 않음.

2. 동적 메모리의 기본.
    - new : 객체(변수)를 힙 메모리에 할당함.
    - delete : 힙 메모리에 있는 객체(변수)를 destroy함.
    - Memory leak : delete를 깜빡한 경우
    - dangling pointer : 포인터가 가리키는 대상이 힙 메모리일 때 포인터는 해제를 안하고, 대상만 delete해버리는 경우. 

3. 동적 메모리를 할당하는 방법.
    - 기본형 : auto* p = new auto(obj); <br/>
    obj와 같은 타입과, 값을 갖는 객체를 동적 메모리에 할당하고, p가 가리키게 함.
    - ex) int* p = new int(33);
    - delete p; 라는 명령어는 p가 가리키는 대상을 동적 메모리에서 해제 한다.
    - p = nullptr;<br/> 
    p는 해당 해제된 주소를 계속 가리키고 있기 때문에 nullptr로 바꿔줘야함.

4. 동적 메모리를 사용한 예시.

```cpp
int i, *pi1 = &i, *pi2 = nullptr
double *pd = new double(33), *pd2 = pd;

delete i; // error : i 는 포인터가 아님.
delete pi1; // undefined : pi1은 힙메모리가 아닌 지역변수를 참조하고 있다.
delete pd; // ok
delete pd2; // undefined : pd2는 pd와 같은 대상을 가리키는데 그 대상은 이미 해제되어있다.
delete pi2; // nullptr은 항상 delete가 되도록 예외처리되어있다.
```

5. 동적 할당의 initialize하는 방법
    - int* pi1 = new int; <br/>
    *pi1은 default initialize되어 쓰레기값이 들어있다.
    - int* pi2 = new int(); <br/>
    *pi2는 value initialize되어 0이 된다.
    - string *ps1 = new string; <br/>
    string은 클래스이기에 생성자에 의해 생성됨. ""
    - string *ps2 = new string(); <br/>
    string의 value initialize인 ""이 들어감.

6. 배열을 동적 할당 하는 방법

- 기본 형태 : 
    - int *pia = new int[10];<br/>
    default initialization. 쓰레기값 10개
    - int *pia2 = new int[10]();<br/>
    value initialization. 0 10개
    - list_intializer를 통해서도 동적 배열을 초기화 할 수 있다.<br/>
    ex) int* parr = new int[10]{1,2,3,4,5,6,7,8,9,10};

- 기본 배열과 다른 이유
    - 동적 할당은 런타임 단계에서 수행되는 과정이기 때문에 배열의 크기에 변수를 둘 수 있다<br/>
    &lrarr; 기본 배열은 배열의 크기에 상수만 가능하다.

- 동적 배열을 해제하는 방법
    - delete [] pa; 와 같이 한다.
    - 만약 n차원 배열을 생성했다면 생성한 역순으로 해제를 해주어야 한다.
    ```cpp
    int** parr = new int*[5];
    for(int i=0; i<5; i++)
    {
        parr[i] = new int[5];
    }
    // 2차원 배열 생성.

    for(int i = 0; i < 5; i++)
    {
        delete[] parr[i];
    }
    delete[] parr;
    ```
---

## 12주차 -1 : Copy Control

### 1. Copy Constructor

- copy constructor의 기본 형태
    - myClass(const myClass& ); <br/>
    자신과 같은 클래스의 참조를 parameter로 받는다.

- parameter가 &타입이어야 하는 이유
    - &가 아니라면 argument를 parameter로 복사해와야 하는데 이 때 copyconstructor가 필요함.
    - 복사 생성자를 만들기 위해 복사 생성자가 필요한 딜레마에 빠지게 된다.

ex) copy constructor
```cpp
class Sales_data{
public:
    Sales_data(const Sales_data&); // 복사 생성자 명시.
private:
    string bookNo;
    int units_sold = 0;
    double revenue = 0.0;
}:

위의 Sales_data(const Sales_data&) 복사 생성자는 아래와 동등한 역할을 한다.

Sales_data::Sales_data(const Sales_data& orig):
    bookNo(orig.bookNo), units_sold(orig.units_sold), revenue(orig.revenue)
    {}

즉, 각각의 멤버 변수에 orig의 멤버 변수를 대입하는 것이다.
그렇게 하기 위해서 생성자에는 보이지 않는 self라는 parameter가 존재한다.
그래서 그냥 멤버 변수를 사용해도 함수를 선언한 객체의 멤버변수라는 것을 나타낸다.
```


### 2. Copy Assignment

- 복사 할당자(?) : operator= 으로 나타낸다.

- 이 = 연산자 오버로딩의 반환값으로는 그 객체의 &(원본)을 반환해야한다.<br/>
(그렇지 않으면 원본이 바뀌지 않으니까.)

ex) copy assignment
```cpp
class Sales_data{
public:
    Sales_data(const Sales_data&); // 복사 생성자 명시.
    Sales_data& operator=(const Sales_data&); // 복사 할당자?
private:
    string bookNo;
    int units_sold = 0;
    double revenue = 0.0;
}:

위의 copy assignment는 아레의 코드와 동등한 역할을 한다.

Sales_data& Sales_data::operator=(const Sales_data& rhs)
{
    this.bookNo = rhs.bookNo;
    this.units_sold = rhs.units_sold;
    this.revenue = rhs.revenue;
    return *this; // 중요.
}

```

### 3. Destructor
- 파괴자, 생성자의 역연산이다. 
- static변수가 아닌 멤버 변수들이 생성될 때의 역순으로 free된다.
- 사용자가 직접 명시하지 않으면 default destructor가 자동으로 생성됨.

ex)
```cpp
Sales_data *p = new Sales_data; 

delete p; // 여기서 destructor가 실행됨.
이 객체가 사라져하 할 타이밍에 실행.
```

### 4. default rule of three.
- 복사생성자, 복사 할당자, 파괴자 이 셋은 서로가 서로를 필요로 하는 관계라는 것을 rule of three라고 하는듯.
- 실제로 operator= 은 lhs의 값은 destroy하고, rhs를 copy하여 넣어야 하기 때문이다.
- default 생성자
```cpp
Sales_data() = default; // default 생성자
Sales_data(const Sales_data&) = default; // default 복사생성자
Sales_data& operator=(const Sales_data&); // default..
~Sales_data() = default // default 파괴자
```

- default생성자들이 생기지 않게 명시해 주기 위해서 = default가 아닌 = delete를 써주기도 한다.
```cpp
Sales_data() = delete; // Sales_data의 기본 생성자가 컴파일러에 의해 생성되지 않음.
```

---

## 12주차 -2 : Copy Control에서의 자원 관리.

### 1. 클래스의 멤버 변수에 string 포인터가 있는 경우의 copy assignment

- 포인터가 있는 경우 기본 생성자를 통해 모든 클래스의 객체가 하나의 string을 가리키고 있을 것이다.
- 그렇게 되면, 한 곳에서 delete ps;를 하면 모든 객체의 ps가 dangling pointer가 된다.
- 그렇기 때문에 operator= 을 정의할 때에도 조심해야함.

ex) 
```cpp
잘못된 예시.
HasPtr& HasPtr::operator=(const HasPtr& rhs)
{
    delete ps; // 여기서 *(rhs.ps)도 같이 날라가버림.
    ps = new string(*(rhs.ps));
    i = rhs.i;
    return *this;
}

옳은 예시
HasPtr& HasPtr::operator=(const HasPtr& rhs)
{
    auto newp = new string(*(rhs.ps));
    // rhs.ps가 가리키는 대상이 없어지기 전에 어디다가 보관해놓음.
    delete ps;
    ps = newp;
    i = rhs.i;
    return *this;
}
```

### 2. 클레스의 멤버 변수에 string 포인터가 있는 경우 destructor

- 이 string이 몇번 복사되었는지를 멤버 포인터 변수를 통해 확인한 후 복사될 때는 +1, delete될 때는 -1을 하다가, 0이 되면 그 때 delete를 해주는 방법.

ex)
```cpp
class HasPtr{
public:
    HasPtr(const std::string& s = std::string()):
        ps(new std:string(s)), i(0), use(new std::size_t(1)) {}
    // 생성자
    HasPtr(const HasPtr& p):
        ps(p.ps), i(p.i), use(p.use) {++*use;}
    // 복사 생성자.
    HasPtr& operator=(const HasPtr&)
    {
        ++*rhs.use;
        if (--*this.use == 0)
        {
            delete ps;
            delete use;
        }
        ps = rhs.ps;
        i = rhs.i;
        use = rhs.use;
        return *this;
    }
    ~HasPtr()
    {
        if(--*use == 0)
        {
            delete ps;
            delete use;
        }
    }
private:
    std::string* ps;
    int i;
    std::size_t *use;
};
/// 생성자
일반 생성자를 통해 만들어진다면 그 string을 ps가 가리키고, 
그 string을 가리키는 개수를 나타내는 *use = 1로 초기화함.
/// 복사 생성자
복사 생성자를 통해 다른 객체를 복사한다면,
포인터를 포함한 모든 멤버 변수를 복사하고, *use를 +1 함.
/// 복사 할당자
복사 할당자를 통해 다른 객체를 할당한다면,
다른 string인 *rhs.ps를 참조하던 *rhs.use를 +1 하고,
lhs의 값들을 destroy하고, rhs값을 복사한다.
/// 파괴자
destructor를 통해 제거될 때에는 ps를 참조한 객체의 수 *use를 하나씩 줄여가며 
0이될 때 ps와 use를 모두 delete한다.
```

### 3. 포인터를 갖는 클래스에서 복사 할당자를 구현하는 또 다른 방법.

- swap함수를 구현해서 rhs와 lhs를 swap하고, lhs를 return한다.
- 그러기 위해서 operator= 의 parameter를 non-reference로 받아야 함.

ex)
```cpp
HasPtr& HasPtr::operator=(HasPtr rhs){
    swap(*this, rhs);
    return *this;
}

이렇게 한다. parameter는 non-const, non-reference여야 함.
```

## 12주차 -3 : Copy-Control의 예시 : 이메일 클래스.

- 이메일 클래스들의 구조.
    - 메시지 클래스와 폴더 클래스가 따로 있다.
    - 메시지 클래스에는 텍스트와 그 메시지가 속해 있는 폴더들에 대한 ptr정보가 들어있다.
    - 폴더 클래스에는 그 폴더에 들어있는 메시지들의 ptr정보가 들어 있다.

- Interface (상상)
    - 메시지 클래스는 save와 remove함수가 있다.
    - 하나의 메시즈는 복사될 수 있고, 복사된다면 두 메시지 모두 같은 폴더들에 들어있어야 한다.
    - 메시지가 Destroying된다면 그 메시지는 더 이상 존재하지 않기 때문에 Message클래스의 folders* set은 제거되어야 한다.
    - assign of Message to another. : a = b와 같이 한 메시지를 다른 메시지에 할당한다면 lhs는 remove되어야 하고, lhs에 rhs가 복사되어야 한다.

- 메시지 클래스의 구현
```cpp
class Message{
    friend class Folder;
public:
    explicit Message(const string& str = "") :
        contents(str) {}
    /// 생성자와 파괴자 정의
    Message(const Message&); // copy constructor
    Message& operator=(const Message&); // copy Assignment
    ~Message(); // Destructor

    void save(Folder&);
    void remove(Folder&);
private:
    string contents;
    set<Folder*> folders;
    void add_to_Folders(const Message&);
    void remove_from_folders();
};

void Message::save(Folder &f)
{
    folders.insert(&f);
    f.addMsg(this); // Message객체의 함수이므로 그 객체를 전달.
}

void Message::remove(Folder& f){
    folders.erase(&f);
    f.remMsg(this);
}
```
- 위에서 contents 변수는 메시지의 내용을 저장함.<br/>
Folder*를 저장하는 folders set컨테이너는 이 메시지가 속해있는 폴더들의 집합을 의미함.<br/>
save(Folder&)는 이 메시지를 특정 폴더에 포함되도록 하는 함수이다.
<br/> 예를 들면 a라는 메시지를 f라는 파일에도 포함되도록 하고 싶다면 a.save(f); 이렇게 사용.
<br/>
remove(Folder&) 함수는 특정 폴더에 이 메시지가 있다면 포함하지 않게 하는 함수이다. <br/>
ex) a.remove(f);

- 메시지의 copy constructor를 구현하기 위해서는 A라는 메시지와 B라는 메시지가 있을 때,<br/>
A라는 메시지의 내용을 B에 저장하고, A가 속해있는 폴더들을 가리키는 folders 집합을 복사해야 한다.<br/>
그러고 나서 그 폴더 하나하나가(folder 객체) 복사된 메시지를 자기가 갖고있다는 것을 나타내기 위해 add_to_Folders함수를 구현해야 함.
```cpp
    void Message::add_to_Folders(const Message& m)
    {
        for (auto f : m.folders)
            f -> addMsg(this); // f가 this를 가지고 있다.
    }

    Message::Message(const Message& m):
        contents(m.contents), folders(m.folders)
    {
        add_to_Folders(m);
    }
```

- 반대로 Destructor에서는 각각의 파일객체에서 이 메시지 객체를 지워주기 위해 remove_from_Folders()함수를 구현.
```cpp
void Message::remove_from_Folders()
{
    for(auto f : folders)
        f->remMsg(this);
    this->folders.clear();
}

Message::~Message()
{
    remove_from_Folders();
}
```

- 이 둘을 합쳐서 copy-assignment를 구현할 수 있다.
```cpp
Message& Message::operator=(const Message& rhs)
{
    remove_from_Folders(); // 본인이 갖고있던 정보를 삭제.
    contents = rhs.contents;
    folders = rhs.folders;
    add_to_Folders(rhs);
    return *this;
}
```

- swap function도 만들 수 있다.
```cpp
void swap(Message& lhs, Message& rhs)
{
    using std::swap;

    // 폴더들 먼저 처리
    for (auto f : lhs.folders)
        f->remMsg(&lhs);
    for(auto f : rhs.folders)
        f->remMsg(&rhs);
    // 메시지 교체
    swap(lhs.contents, rhs.contents);
    swap(lhs.folders, rhs.folders);

    // 폴더들 처리.
    for(auto f : lhs.folders)
        f->addMsg(&lhs);
    for(auto f : rhs.folders)
        f->addMsg(&rhs);
}
```

---

## 12주차 - 4. StrVector 구현.

- 몇몇 클래스들은 런타임에 동적 메모리를 할당해야 하는 경우가 있다. (container들의 경우.)
- 또한 몇몇 클래스는 그들만의 allocation(할당 알고리즘)이 필요하다.
- 그렇게 하기 위해서 그 클래스만의 copy-control과 동적 메모리를 처리할 멤버가 필요하다.

1. StrVec 클래스 Design.
    - 이 클래스는 vector<string>과 같이 행동하게 하고 싶다.
    - 이 클래스는 원소를 연속적으로 저장한다(주소가.)
    - 이 클래스는 필요하다면 저장 공간을 더 늘려서 원소를 저장한다.
    - 각각의 클래스 객체(vector)들은 원소가 더 들어올 공간이 있는지를 확인하고, <br/>
    그렇다면, 다음 위치에 원소를 생성한다.<br/>
    남은 공간이 없다면, 공간이 더 큰 새로운 주소로 이사를 간다.<br/> 원래 있던 공간을 없앤 다음에 새로운 원소를 새집에 추가한다.

2. StrVec 클래스 interface
    - 우리는 메모리의 공간을 가져오기 위해 allocator를 사용할 것이다.
    - allocator의 constructor를 사용한다.
    - 비슷하게 원소를 지울때고 allocator의 destructor를 사용한다.

3. StrVec클래스의 세가지 포인터 변수.
    - elements : 할당된 메모리의 첫번째 원소를 가리킴.
    - first_free : 다음 원소가 들어올 위치를 가리킴.
    - cap : allocator로 할당된 마지막 주소를 가리킴. (capacity)

4. allocator와 멤버 함수.
    - strVec에서 사용할 allocator를 static 멤버로 선언한다. <br/>allocator<string> alloc;
    - alloc_n_copy 함수는 공간을 할당하고, 주어진 범위의 원소를 복사하는 역할을 한다.
    - free 함수는 생성된 원소들을 destroy하고, 공간을 반환한다.
    - chk_n_alloc 함수는 원소가 들어올 공간이 남아있는지를 확인한다.
    - reallocate 함수는 공간이 없을 때 공간을 재할당하는 함수이다.

5. StrVec 클래스 정의
```cpp
class StrVec{
public:
    StrVec(): // default constructor
        elements(nullptr), first_free(nullptr), cap(nullptr){}
    StrVec(const StrVec& );
    StrVec& operator=(const StrVec&);
    ~StrVec();

    void push_back(const std::string&);
    size_t size() const {return first_free - elements;}
    size_t capacity() const { return cap - elements;}
    std::string* begin() const { return elements;}
    std::string* end() const {return first_free;}
    // ...

private:
    static std::allocator<std::string> alloc;
    void chk_n_alloc()
    {
        if (size() == capacity())
            reallocate();
    }
    std::pair<std::string*, std::string*> alloc_n_copy(const std::string*, const std::string*);
    void free();
    void reallocate();
    std::string* elements;
    std::string* first_free;
    std::string* cap;
};
// alloc은 헤더파일이 아니라 소스파일에 정의되어야함.
allocator<string> StrVec::alloc;
```

- allocator의 construct를 이용한 push_back의 구현.
```cpp
void StrVec::push_back(const string& s)
{
    chk_n_alloc(); // 공간이 없다면 공간을 늘림.
    alloc.construct(first_free++, s); // first_free위치에 s를 삽입.
}
```

- StrVec의 copy constructor와 copy assignment에 사용할 alloc_n_copy구현.
- alloc_n_copy 는 StrVec의 copy constructor나 copy assignment에 이용된다.
- alloc_n_copy는 새로운 공간을 만들고, 새로운 공간에 parameter로 주어진 범위의 원소들을 복사한다.
- 아레의 예시에서는 data가 새로 할당된 공간이고, b~e의 요소를 data에 복사한다.
```cpp
pair<string*, string*>StrVec::alloc_n_copy(const string* b, const string* e)
{
    auto data = alloc.allocate(e-b);
    return {data, uninitialized_copy(b, e, data)};
    // first의 data는 할당된 공간의 첫번 째 위치를 반환.
    // second는 data의 위치에 b~e의 요소들을 복사하는 함수.
    // 반환값은 data + e-b의 위치를 반환함. 그래서 string*임.
    즉, 이 함수는 새로 copy한 공간의 elements위치와 first_free위치를 반환함.
}
```
- free 멤버 함수 구현.
- 아레의 예시에서 elements가 nullptr(StrVec에 원소가 없을 때), 이 아니라면 alloc이 할당한 공간의 원소들을 하나씩 destroy하며, 마지막엔 공간까지 없앰.
```cpp
void StrVec::free()
{
    if (elements){
        for (auto p = first_free; p != elements; )
            alloc.destroy(--p);
        // alloc.destroy는 그 공간의 객체를 파괴해줌.
        alloc.deallocate(elements, cap - elements);
    }
}
```

- Copy-control Members (복사 생성자.)
```cpp
StrVec::StrVec(const StrVec& s) 
{
    auto newdata = alloc_n_copy(s,begin(), s.end());
    elements = newdata.first;
    first_free = cap = newdata.second;
}
```

- destructor
```cpp
StrVec::~StrVec() { free(); }
free는 위에서 정의함.
```

- copy assignment
```cpp
StrVec& StrVec::operator=(const StrVec& rhs)
{
    auto data = alloc_n_copy(rhs.begin(), rhs.end());
    free();
    elements = data.first;
    first_free = cap = data.second;
    return *this;
}
```

- Reallocation함수에 대하여.
    1. Reallocate 함수는 더 큰 새로운 공간을 할당해줌.
    2. construct로 원래 있던 공간의 원소들을 새로운 공간에 복사함.
    3. 원래 있던 공간의 워소들은 desturct함.
    4. 근데 이게 할당하고, 삭제하고 하는데 오버헤드가 부하되니 Move Constructor를 배워야 함.

- std::move를 이용한 reallocate 함수 구현.
    1. utility 헤더파일에 있다.
```cpp
void StrVec::reallocate()
{
    // 새로운 공간을 할당할건데 원소가 없었다면 1로.
    // 원소가 있었다면 2배로 늘림.
    auto newcapacity = size() ? 2 * size() : 1;
    auto newdata = alloc.allocate(newcapacity);
    // newdata에는 새로운 공간의 시작 주소가 들어있다. 
    auto dest = newdata;
    auto elem = elements; // 지금 객체의 elements주소.
    for(size_t i = 0; i != size(); ++i)
        alloc.construct(dest++, std::move(*elem++));
    // alloc의 construct 함수는 dest의 위치에
    // move표현식으로 표현된 객체를 생성하는 함수이다.

    free();
    elements = newdata;
    first_free = dest;
    cap = elements + newcapacity;
}
```
---

## 6. allocator 클래스
- new로 할당하는 것과 비슷하지만 다르다.
- 할당과 초기화의 분리.
    - new는 클래스의 생성자를 호출해서 메모리를 할당하고, 초기화함.
    - allocator는 allocate함수로 메모리를 할당하고, construct함수로 초기화함.
- 할당할 메모리의 크기 지정.
    - new는 객체 타입만 명시하면 알아서 메모리 크기를 자동으로 할당함
    - allocator는 allocate함수로 메모리 크기를 제어할 수 있어서, 좀 더 세밀한 컨트롤이 가능.
- 할당된 메모리의 해제
    - new로 할당된 메모리는 delete를 통해 해제
    - allocator로 할당된 메모리는 deallocate함수로 해제, 또한 destroy함수를 통해 객체의 소멸자를 직접 호출할 수 있다.
- allocator클래스의 할당 컨트롤.
    - auto p = alloc.allocate(vi.size() * 2);<br/>
    p는 새로운 공간의 시작 주소를 가리킴.<br/>
    elements의 위치
    - auto q = uninitialized_copy(vi.begin(), vi.end(), p); <br/>
    q는 p가 가리키는 새로운 공간에 vi.begin() ~ vi.end()의 원소들을 넣은 마지막 위치를 가리킴<br/>
    first_free의 위치
    - uninitialized_fill_n(q, vi.size(), 42);<br/>
    이 함수는 void형이고, q가 가리키는 공간에 vi.size()만큼의 42를 채워넣음.

## 13주차 연산자 오버로딩.
- 연산자 오버로딩이란?
    - 연산자 오버로딩은 특별한 이름을 가진 함수와 비슷하다.
    - opeator=, operator&, operator[]...
    - 이 연산자 오버로딩도 parameter를 갖는다.<br/>
    ex) int operator+(int, int);<br/>
    이건 예시일 뿐이지 원래는 built-in타입의 연산자는 오버로딩 못함.
    - data1 + data2 와 operator+(data1, data2)는 완전한 동치임.
    - 왠만해서는 내가 정의한 클래스에서 객체 간의 연산을 수행하도록 하고 싶을 때 쓰인다.
    - 같은 클래스에 대한 연산은 클래스의 멤버로 정의하는게 좋다.

### 1. I/O 연산자 <<, >>의 오버로딩.
- Output stream의 기본 형태 : <br/>
```cpp
osteam& operator<<(ostream& os, const Sales_data& item)
{
    os << item.isbn() << ' ' << item.units_sold << ' ' << item.revenue << ' ' << item.avg_price();
    return os;
}
```
위의 << 연산자 오버로딩은 원래라면 안될 cout << Sales_data를 가능하게 한다.<br/>
위의 연산자 오버로딩을 통해서 cout이 위의 행동을 알아들을 수 있게 함.<br/>
만약 operator<<를 클래스의 멤버로 정의했다면 <br/>
data << cout 과 같이 순서가 반대여도 상관은 없다.<br/>
하지만 햇갈리니까 원래 순서대로 쓰자.

- Isteam의 기본 형태 : <br/>
```cpp
istream& operator>>(istream& is, const Sales_data& item)
{
    double price;
    is >> item.bookNo >> item.units_sold >> price;
    if(is)
        item.revenue = item.units_sold * price;
    else
        item = Sales_data(); // 입력에 실패하면 기본 생성자를 이용해서 
        // 원래의 상태로 되돌림.
    return is;
}
```
if(is)는 입력이 제대로 받아졌다면 True.<br/>
위의 오버로딩은 원래라면 안됐을 is >> Sales_data 을 할 수 있게 한다.

### 2. 산술 및 관계 연산자 오버로딩.
- interface : 
    - 일반적으로 산술 및 관계 연산자들은 서로 형변환이 되는 경우가 많기 때문에 클래스의 멤버로 정의하지 않는게 일반적이다.<br/>
    ex) 3 + 3.5
    - 매개 변수로는 상태를 변경할 필요가 없기 때문에 const로 받는다.
    - return type : 두 피연산자에 대한 결과의 복사본을 반환한다.<br/>
    ex) + 연산자의 경우(산술 연산자.)
    ```cpp
    Sales_data operator+(const Sales_data &lhs, const Sales_data& rhs)
    {
        // 반환 타입은 sales_data. 
        Sales_data sum = lhs;
        sum += rhs;
        return sum;
    }
    ```
    ex) ==나 != 연산자의 경우.(관계 연산자.)
    ```cpp
    bool operator==(const Sales_data &lhs, const Sales_data &rhs)
    {
        return  lhs.ishn() == rhs.ishn() &&
                lhs.units_sold == rhs.units_sold &&
                lhs.revenue == rhs.revenue;
    }

    bool operator!=(const Sales_data &lhs, const Sales_data &rhs)
    {
        return !(lhs == rhs);
        ==이나 != 중 하나만 만들어 놓으면 다른 하나는 만들필요 없다.
    }
    ```
하지만 !=연산자가 필요하다는 것은 다른 한쪽이 크거나 작거나 하는 >, <연산이 필요할 수도 있다는 것을 생각하자.

### 3. 복합 할당 연산자 +=
- 복합 할당 연산자는 클래스 내부에서 정의할 강제는 없다.
- 하지만 ==이나 +=은 왠만해선 클래스 내부에서 정의하곤 한다.
- 복합 할당 연산자의 반환형 : <br/>
left-hand 객체의 참조형을 반환한다.
ex) +=
```cpp
Sales_data& Sales_data::operator+=(const Sales_data& rhs)
{
    units_sold += rhs.units_sold;
    revenue += rhs.revenue;
    return *this;
}
```
- 연산자 오버로딩도 여러 parameter타입(rhs 타입)에 대해서 다중화 할 수 있다.

### 4. Subscript Operator [].
- 배열과 같이 []연산자를 통해 원소에 접근하는 연산도 오버로딩 할 수 있다.
- 반환형 : 원소의 참조를 반환한다.
- []연산자는 보통 const 타입과 non-const타입 둘 다를 정의하는 경우가 많다<br/>
const 객체에 대해서 이 연산을 수행하는 경우 const 원소의 참조를 반환해주기 때문에 값을 할당하거나 바꿀 수 없게 해준다.<br/>
ex) StrVec에서의 []연산자 오버로딩.
```cpp
class StrVec{
public:
    std::string& operator[](std::size_t n)
    {return elements[n];}
    const std::string& operator[](std::size_t n) const 
    { return elements[n];}
private:
    std::string* elements;
};

int main()
{
    StrVec svec = {~~~};
    const StrVec cvec = svec;
    // svec은 non-const, cvec은 const객체이다.
    if(svec.size() && svec[0].empty()){
        svec[0] = "zero"; // ok
        cvec[0] = "Zip"; // Error
        []연산자에 의해서 cvec[0]는 const type이기 때문.
    }
}
```

### 5. Increment and Decrement Operator (++, --)
- 여기서는 a++과 ++a를 구분해야 한다. <br/>
하는 일이 완전히 다르기 때문에.
- 클래스의 멤버일 필요는 없지만, 객체의 상태를 변경하므로 클래스의 멤버이면 좋다.
- prefix 버젼의 Increment operator<br/>
ex) ++a
```cpp
    StrBlobPtr StrBlobPtr::operator++()
    {
        check(curr, "Increment past end of StrBlobPtr");
        ++curr; // curr은 포인터라 ++가 기본으로 있음.
        return *this;
    }
위의 코드는 ++a과 같이 먼저 증가시키고, 증가된 객체를 반환한다.
```
ex) a++
```cpp
    StrBlobPtr StrBlobPtr::operator++(int) // 여기가 달라.
    {
        check(curr, "Increment end of StrBlobPtr");
        StrBlobPtr ret = *this;
        ++*this;
        return ret;
    }
위의 코드는 a++을 정의하는데 미리 정의된 prefix-version을 이용했다.
객체를 미리 복사해 놓고, 객체는 증가시키고, 복사한 값을 반환해 준다.
```

### 6. 역참조 연산자 (*, ->)
- 또한 객체에 직접 접근하므로 멤버로 정의하나봄.
- 객체의 값을 변경시키면 안되므로 const 한정자를 붙여준다.<br/>
ex) *, ->
```cpp
class StrBlobPtr{
public:
    std::string& operator*() const // const.
    {
        auto p = check(curr, "dereference past end");
        return (*p)[curr];
    }
    std::string* operator->() const //
    {
        return & this->operator*();
    }
위의 *연산자 오버로딩에서는 이 객체의 curr가 가리키는 주소에
*p[curr]로 접근해서 그 원소를 반환한다.
이를 이용해서 ->오버로딩에서 그 원소의 주소를 반환한다.
}
```

### 7. 클래스를 함수처럼 사용하는 function-call operator <br/>(이거 시험에 나올것같음. 두개로 쓰는거.)
- 클래스 내부에서 ()에 대한 연산자 오버로딩을 이용하면 객체() 이런식으로 함수처럼 사용 가능.<br/>
ex) 절댓값을 반환하는 클래스함수.
```cpp
struct absInt{
    int operator()(int i) const
    {
        return val < 0 ? -i : i;
    }
};
int i = -42;
absInt absObj;
std::cout << absObj(i);

-----------------------------------
output : 42
```

- 이러한 클래스 함수? 를 통해서 람다 함수의 동작을 이해할 수 있다.
- 람다 함수의 표현식도 컴파일러가 이름없는 클래스의 객체라고 변환해서 사용하게 됨.
ex) stable_sort
```cpp
stable_srt(words.begin(), words.end(), [](const string& a, const string& b)
{return a.size() < b.size();});

위의 람다 표현식을 이용한 stable_sort와
클래스의 ()연산자 오버로딩을 이용한 stable_sort는
컴파일러의 입장에선 완전히 동등한 표현이다.

class ShorterString{
public:
    bool operator()(const string& a, const string& b) const
    {
        return a.size() < b.size();
    }
};

stable_srot(words.begin(), words.end(), ShorterString());
```

## 14주차 객체 지향 프로그래밍(OOP)
### 1. 객체 지향 프로그래밍 개요.
- 주요 아이디어
    - 데이터 추상화 : <br/>
    클래스의 인터페이스와 구현을 분리할 수 있다.
    - 상속 :<br/>
    유사한 유형 간의 관계를 모델링하는 클래스를 정의할 수 있다.
    - 동적 바인딩 : <br/>
    어떻게 다른지에 대한 디테일을 모른 채 객체를 사용할 수 있다.

- 상속이란?
    - 여러 클래스가 있고, 공통된 멤버를 갖는다면 이들을 포함하는 루트 클래스를 만들 수 있다.(부모 클래스의 정의)<br/>
    - 이 루트 클래스를 상속받은 클래스들은 부모 클래스의 멤버를 공통적으로 가지고 있다.(상속을 사용하는 이유)<br/>
    - 자식 클래스는 각자의 멤버를 정의하여 사용할 수 있다.<br/>
    ex) 상속의 예시. 
```cpp
class Quote // 부모 클래스
{
public:
    std::string isbn() const;
    virtual double net_price(std::size_t n) const; // 가상 함수.
    virtual double net_price(std::size_t n) const = 0; // pure virtual funtion
};

class Bulk_quote : public Quote // 자식 클래스 정의
{
public:
    double net_price(std::size_t) const override;
    // override를 붙임으로서 재정의된 함수라고 명시.
};

-------------------------------

부모 클래스에서 virtual function을 정의함으로서, 자식 클래스에서는 이 함수를
재정의 할 수 있다. 하지만 그냥 가상 함수로 선언하면 강제는 아니다.

하지만 가상 함수의 정의 끝에 =0을 붙임으로서 pure virtual 함수로 만들 수 있는데,
이렇게 정의된 가상 함수는 자식 클래스에서의 재정의가 강제된다.
재정의를 하지 않는다면 자식클래스는 객체를 생성할 때 에러가 발생함.
```

- 동적 바인딩이란?
    - 부모 클래스는 자식클래스로도 할당될 수가 있다.
    - 자식 클래스의 내부에 부모 클래스가 일부 들어있기 때문에.<br/>
    ex) 
    ```cpp
    double print_total(ostream& os, const Quote& item, size_t n)
    {
        ~~~
    }

    Quote q;
    Bulk_quote q2;

    print_total(cout, q, 20)
    print_total(cout, q2, 20)

    --------------------

    위의 코드에서 print_total 함수는 두번째 인자로 Quote객체를 받아온다고
    되어 있지만 Quote 클래스를 상속받은 Bulk_quote 객체가 와도 동작하는 것을
    볼 수 있다. 
    이를 동적 바인딩이라고 한다.
    ```

### 2. 부모, 자식 클래스를 정의하는 방법.
- 부모 클래스의 정의
    - 파생(자식) 클래스는 기본(부모) 클래스의 멤버들을 상속한다.
    - 하지만 자식 클래스에서 재정의를 하게 하고싶은 함수가 있다면 virtual로 선언한다.
    - virtual함수는 기본적으로 static멤버가 아닌 함수에 대해서 선언 가능.
    - virtual함수가 아닌 경우의 멤버함수들은 컴파일 시간에 처리된다.(inline)

- 자식 클래스의 정의
    - 자식 클래스는 어떤 base 클래스를 상속했는지 명시해야 한다. <br/>
    ex) class Bulk_quote : public Quote
    - 위의 예시에서 Bulk_quote클래스는 Quote클래스를 상속했는데,
    public의 의미는 클래스 외부에서 객체를 통한 접근에서 부모 클래스의 최소 접근 제한을 public으로 한다는 의미이다.<br/>
    (만약 private이었다면 부모 멤버의 public과 protected 한정자가 객체를 통한 접근에서는 private으로 여겨짐.)
    - 대부분의 클래스는 하나의 클래스만을 상속한다.
    (우리 수업은 하나만 한다.)
    - 자식클래스는 생성자를 만들 때 부모클래스의 생성자를 이용해야 한다.
        - 자식 클래스의 객체를 만드는 경우에 부모 클래스의 멤버도 만들어지고, 초기화가 되어야 하기 때문에.

- 부모 자식간의 접근 제한.
    - 자식 클래스는 부모 클래스의 public, protected 멤버들에 대해 접근 가능하다.

- 자식 클래스의 객체는 부모 클래스의 객체처럼 사용이 가능하다. 
    - 위의 동적 바인딩 참고.
    - 포인터나 참조자에 대해서도 가능.<br/>
    ex) 
    ```js
    Quote item;
    Bulk_quote bulk;
    Quote* p = &item;
    p = &bulk; // 부모클래스 포인터가 자식 클래스를 가리킴.
    Quote& r = bulk; // 참조자도 마찬가지.
    --------------------------
    하지만 부모 클래스의 객체는 자식 클래스처럼 사용될 수 없다.

    Quote item;
    Bulk_quote bulk;
    Bulk_quote* p = &bulk;
    p = &item; // Error! 
    --------------------------
    이는 자식클래스 내부에 부모 클래스가 포함되어있기 때문에 가능한 일이다.
    부모 클래스 내부에는 자식 클래스가 들어있지 않기 때문에 자식 클래스처럼 
    행동할 수 없다.
    ```
- 상속 관계에서의 static 멤버.
    - 자식 클래스들과 부모 클래스 모두에서 static멤버는 하나만 존재하게 된다.

- 상속되는 것을 막는 final 키워드
    - 클래스 이름 뒤에 final 키워드를 넣으면 이 클래스를 상속받을 수 없게 된다.

### 3. Virtual Functions.
- 가상 함수의 다형성.
    - 부모 클래스에서 virtual함수가 정의되어있고, 자식 함수에서 override하여 같은 이름의 여러 개의 함수가 생길 수 있다.
    - 그렇다면 base_obj.virtual_func()를 하면 부모 클래스의 virtual함수가 실행이 되고,<br/>
    derived_obj.virtual_func()를 하면 자식 클래스의 virtual 함수가 실행이 된다.
    - 이는 동적 바인딩 된 함수 파라미터에도 적용됨.
    - 가상 함수는 한번 상속이 되면, 자식의 자식 클래스에서도 계속 재정의를 해주어야 한다.<br/>
    하지만 final키워드를 통해 이 가상 함수가 더이상 상속되지 않게 해줄 수 있다.
    - 하지만 자식 객체에서 부모의 virtual function을 사용하고 싶을 때도 있을 것이다.<br/>
    그럴 때는 derived_obj.base::virtual_func();와 같이 scope operator를 사용해서 접근할 수 있다.

### 4. 상속과 접근 제한자
- friend 접근 제한자.
    1. friend로 선언된 클래스는 private까지 모두 접근할 수 있다.
    2. friend로 선언된 클래스는 friend접근 제한자까지 상속되지는 않는다.

- 자식 클래스에서의 using을 통한 부모 클래스 멤버의 접근 제한자를 바꾸어줄 수 있다.
    - 부모에서 public이지만 상속받을 때 private으로 받은 경우 : <br/>
    클래스 외부에서 그 멤버는 private이기 때문에 접근할 수 없다.<br/>
    하지만 using Base::base_mem; 을 public제한자에 선언하면 클래스 외부에서 그 멤버는 public으로 접근할 수 있게 된다.
    - 부모에서 protected였던 경우. : <br/>
    클래스 외부에서 그 멤버는 protected라서 접근할 수 없다.<br/>
    public 으로 using Base::base_mem; 을 선언하면 클래스 외부에서 public으로 접근 가능.

### 5. 상속 관계에서의 scope 연산자.
- 컴파일러의 함수를 찾는 과정
    1. 현재 객체에서 그 함수가 있는지 확인함.
    2. 없다면 그 함수의 부모 클래스에서 그 함수가 있는지 확인함.
    3. 이를 반복.

- 부모 클래스와 자식 클래스의 함수 이름이 같은 경우.
    - 부모 클래스의 함수와 자식 클래스의 함수의 이름이 같은 경우 자식 클래스의 객체의 입장에서는 부모 클래스의 함수가 보이지 않게 됨.<br/>
    그렇기 때문에 Base::func 와 같이 명시해 주어야 함.
    - 명시해주지 않으면 만약 함수의 parameter타입이 다르다면 컴파일러는 자식 클래스의 함수 인자 타입만 보고 error를 띄우게 됨.

ex) 함수를 찾는 예시
```cpp
class Base{
public:
    virtual int fcn();
};

class D1 : public Base {
public:
    int fcn(int);
    virtual void f2();
};

class D2 : public D1{
public:
    int fcn(int);
    int fcn();
    void f2();
}

Base bobj; D1 d1obj; D2 d2obj;

Base* bp1 = &bobj, *bp2 = &d1obj, *bp3 = &d2obj;
// Base가 루트이므로 다른 객체를 모두 가리킬 수 있다.
bp1->fcn(); // Base::fcn()
bp2->fcn(); // Base::fcn()
bp3->fcn(); // D2::fcn()

D1* d1p = &d1obj; D2* d2p = &d2obj;
// 각자 자신의 객체를 가리킴.
bp2->f2(); // Error! Base클래스는 f2가 없다?
d1p->f2(); // D1::f2()
d2p->f2(); // D2::f2()

Base* p1 = &d2obj; D1* p2 = &d2obj; D2* p3 = &d2obj;
p1->fcn(42); // Error Base는 fcn(int)가 없다
p2->fcn(42); // D1::fcn(int)
p3->fcn(42); // D2::fcn(int)

-------------------------------------------
위의 예시를 통해 컴파일러가 함수를 찾을 때는 그 객체가 가리키는 타입이 아닌 
객체 본인의 타입에서 먼저 찾고, 부모로 올라가면서는 찾을 수 있지만,
자식으로 내려가면서는 찾을 수 없다는 것을 알 수 있다.
```

### 6. Virtual Destructor와 constructor.
- 부모 클래스가 소멸자를 virtual로 선언하면 Rule of Three의 예외가 된다.
- 부모 클래스의 소멸자를 virtual로 선언하고, 자식 클래스의 소멸자가 override로 선언되면<br/>
자식 클래스의 객체가 destroy될 때 자식 클래스의 소멸자 실행 &rarr; 부모 클래스의 소멸자도 자동으로 호출된다.
